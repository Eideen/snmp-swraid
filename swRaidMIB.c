/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.iterate_access.conf,v 1.12 2006/09/08 15:43:39 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "swRaidMIB.h"
#include "swRaidMIB_access.h"


/*
 * Initialize the swRaidTable table by defining its contents and how it's structured
 */
void initialize_table_swRaidTable(void)
{
  static oid swRaidTable_oid[] = { SWRAIDTABLE_OID };
  netsnmp_table_registration_info *table_info;
  netsnmp_handler_registration *my_handler;
  netsnmp_iterator_info *iinfo;

  /*
   * create the table registration information structures
   */
  table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
  iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

  my_handler = netsnmp_create_handler_registration("swRaidTable",
                                                   swRaidTable_handler,
                                                   swRaidTable_oid,
                                                   OID_LENGTH
                                                   (swRaidTable_oid),
                                                   HANDLER_CAN_RONLY);

  if (!my_handler || !table_info || !iinfo) {
	snmp_log(LOG_ERR, "malloc failed in initialize_table_swRaidTable");
	return;
  }

  /*
   * setup the table's definition
   */
  netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER, 0);

  /*
   * Define the minimum and maximum accessible columns.  This
   * optimizes retrival.
   */
  table_info->min_column = SWRAIDTABLE_MIN_COL;
  table_info->max_column = SWRAIDTABLE_MAX_COL;

  /*
   * iterator access routines
   */
  iinfo->get_first_data_point = swRaidTable_get_first_data_point;
  iinfo->get_next_data_point = swRaidTable_get_next_data_point;

  /*
   * tie the two structures together
   */
  iinfo->table_reginfo = table_info;

  /*
   * registering the table with the master agent
   */
  netsnmp_register_table_iterator(my_handler, iinfo);
}


/*
 * Initializes the swRaidMIB module
 */
void init_swRaidMIB(void)
{
  static oid swRaidMIB_oid[] = { SWRAIDMIB_OID };
  static oid swRaidErrorFlag_oid[] = { SWRAIDERRORFLAG_OID };
  static oid swRaidErrMessage_oid[] = { SWRAIDERRMESSAGE_OID };

  DEBUGMSGTL(("swRaidMIB", "Initializing swRaidMIB\n"));

  /*
   * Perform swRaidMIB one-time module initialization.
   */
  netsnmp_register_scalar(netsnmp_create_handler_registration
                          ("swRaidErrorFlag", swRaidErrorFlag_handler,
                           swRaidErrorFlag_oid,
                           OID_LENGTH(swRaidErrorFlag_oid),
                           HANDLER_CAN_RONLY));
  netsnmp_register_scalar(netsnmp_create_handler_registration
                          ("swRaidErrMessage", swRaidErrMessage_handler,
                           swRaidErrMessage_oid,
                           OID_LENGTH(swRaidErrMessage_oid),
                           HANDLER_CAN_RONLY));

  /*
   * here we initialize all the tables we're planning on supporting
   */
  initialize_table_swRaidTable();

  /*
   * initialize the cache handler for the entire swRaidMIB branch
   */
  netsnmp_register_cache_handler(netsnmp_create_handler_registration
                                 ("swRaidMIBCache", NULL,
                                  swRaidMIB_oid, OID_LENGTH(swRaidMIB_oid), 0),
                                 SWRAID_CACHE_TIMEOUT,
                                 swRaidMIB_load, swRaidMIB_free);
}


/*
 * Handles requests for the swRaidTable table, if anything else needs to be done
 */
int swRaidTable_handler(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
  netsnmp_request_info *request;
  netsnmp_table_request_info *table_info;
  netsnmp_variable_list *var;
  void *data_context = NULL;

  /*
   * column and row index encoded portion
   */
  for (request = requests; request; request = request->next) {
	var = request->requestvb;
	if (request->processed != 0)
		continue;
	if (reqinfo->mode != MODE_GET) {
		snmp_log(LOG_ERR, "problem encountered in swRaidTable_handler: unsupported mode\n");
		continue;
	}

	/*
	 * get next data context
	 */
	data_context = netsnmp_extract_iterator_context(request);
	if (data_context == NULL) {
		netsnmp_set_request_error(reqinfo, request,
					SNMP_NOSUCHINSTANCE);
		continue;
	}

	/*
	 * extracts the information about the table from the request
	 *   table_info->colnum contains the column number requested
	 *   table_info->indexes contains a linked list of snmp variable
	 *   bindings for the indexes of the table.  Values in the list
	 *   have been set corresponding to the indexes of the
	 *   request
	 */
	table_info = netsnmp_extract_table_info(request);
	if (table_info == NULL)
		continue;
	switch (table_info->colnum) {
		case COLUMN_SWRAIDINDEX:
			{
				long   *retval;
				size_t  retval_len = 0;
				retval = get_swRaidIndex(data_context, &retval_len);
				if (retval != NULL)
					snmp_set_var_typed_value(var, ASN_INTEGER,
					                         (const u_char *) retval,
					                         retval_len);
			}
			break;

		case COLUMN_SWRAIDDEVICE:
			{
				char   *retval;
				size_t  retval_len = 0;
				retval = get_swRaidDevice(data_context, &retval_len);
				if (retval != NULL)
					snmp_set_var_typed_value(var, ASN_OCTET_STR,
					                         (const u_char *) retval,
					                         retval_len);
			}
			break;

		case COLUMN_SWRAIDPERSONALITY:
			{
				char   *retval;
				size_t  retval_len = 0;
				retval = get_swRaidPersonality(data_context, &retval_len);
				if (retval != NULL)
					snmp_set_var_typed_value(var, ASN_OCTET_STR,
					                         (const u_char *) retval,
					                         retval_len);
			}
			break;

		case COLUMN_SWRAIDUNITS:
			{
				char   *retval;
				size_t  retval_len = 0;
				retval = get_swRaidUnits(data_context, &retval_len);
				if (retval != NULL)
					snmp_set_var_typed_value(var, ASN_OCTET_STR,
					                         (const u_char *) retval,
					                         retval_len);
			}
			break;

		case COLUMN_SWRAIDUNITCOUNT:
			{
				long   *retval;
				size_t  retval_len = 0;
				retval = get_swRaidUnitCount(data_context, &retval_len);
				if (retval != NULL)
					snmp_set_var_typed_value(var, ASN_INTEGER,
					                         (const u_char *) retval,
					                         retval_len);
			}
			break;

		case COLUMN_SWRAIDSTATUS:
			{
				long   *retval;
				size_t  retval_len = 0;
				retval = get_swRaidStatus(data_context, &retval_len);
				if (retval != NULL)
					snmp_set_var_typed_value(var, ASN_INTEGER,
					                         (const u_char *) retval,
					                         retval_len);
			}
			break;

		default:
			/* We shouldn't get here */
			snmp_log(LOG_ERR, "problem encountered in swRaidTable_handler: unknown column\n");
	}
  }
  return SNMP_ERR_NOERROR;
}


/*
 * handles requests for swRaidErrorFlag
 */
int swRaidErrorFlag_handler(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
  long   *retval;
  size_t  retval_len = 0;

  if (reqinfo->mode != MODE_GET) {
	snmp_log(LOG_ERR, "unknown mode (%d) in handle_swRaidErrorFlag\n", reqinfo->mode);
	return SNMP_ERR_GENERR;
  }

  retval = get_swRaidErrorFlag(&retval_len);
  if (retval != NULL)

	snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
	                         (const u_char *) retval,
	                         retval_len);

  return SNMP_ERR_NOERROR;
}


/*
 * handles requests for swRaidErrMessage
 */
int swRaidErrMessage_handler(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
  char   *retval;
  size_t  retval_len = 0;

  if (reqinfo->mode != MODE_GET) {
	snmp_log(LOG_ERR, "unknown mode (%d) in handle_swRaidErrMessage\n", reqinfo->mode);
	return SNMP_ERR_GENERR;
  }

  retval = get_swRaidErrMessage(&retval_len);
  if (retval != NULL)
	snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
	                         (const u_char *) retval,
	                         retval_len);

  return SNMP_ERR_NOERROR;
}

