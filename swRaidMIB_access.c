
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.access_functions.conf,v 1.9 2004/10/14 12:57:33 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "swRaidMIB_access.h"



/*
 ****************************************************************************
 *
 * Routines to read and parse the /proc/mdstat file contents
 *
 ****************************************************************************
 */

/*
 * Name of input file
 */
#ifndef PATH_MDSTAT
# define PATH_MDSTAT	"/proc/mdstat"
#endif


/*
 * Maximum line length
 */
#define MAX_LINE_LEN	255


/*
 * Structure holding one input line as part of a linked list
 */
struct input_line {
	struct input_line *next;
        char               line[MAX_LINE_LEN];

	/* swRaidIndex(1)/INTEGER32/ASN_INTEGER/long(long)//l/A/w/e/R/d/h */
	long               swRaidIndex;

	/* swRaidDevice(1)/DisplayString/ASN_OCTET_STR/char(char)//L/A/w/e/R/d/H */
	char              *swRaidDevice;
	size_t             swRaidDevice_len;

	/* swRaidPersonality(2)/DisplayString/ASN_OCTET_STR/char(char)//L/A/w/e/R/d/H */
	char              *swRaidPersonality;
	size_t             swRaidPersonality_len;

	/* swRaidUnits(3)/DisplayString/ASN_OCTET_STR/char(char)//L/A/w/e/R/d/H */
	char              *swRaidUnits;
	size_t             swRaidUnits_len;

	/* swRaidUnitCount(4)/INTEGER32/ASN_INTEGER/long(long)//l/A/w/e/r/d/h */
	long               swRaidUnitCount;

	/* swRaidStatus(5)/RaidStatusTC/ASN_INTEGER/long(u_long)//l/A/w/E/r/d/h */
	u_long             swRaidStatus;
};

static struct input_line *lines = NULL;



/*
 * Clear old file contents
 */
static void ClearFile(void)
{
  struct input_line *p;

  while (lines != NULL) {
	p = lines;
	lines = lines->next;
	free(p);
  }
}


/*
 * Parse the current input line
 */
static int ParseLine(struct input_line *linep, char *buf)
{
  char *cp, *temp;
  int  lineidx;
  size_t toklen;

  /*
   * Copy line into structure and remove any newline characters
   */
  cp = buf;
  temp = linep->line;
  toklen = 0;
  while (*cp != '\0' && *cp != '\n' && toklen < (MAX_LINE_LEN - 1)) {
	*temp++ = *cp++;
	toklen++;
  }
  if (toklen >= (MAX_LINE_LEN - 1)) {
	/* Input line is too long */
	return(FALSE);
  }
  *temp = '\0';

  /*
   * Now parse input line into seperate items
   */
  lineidx = 0;
  cp = strtok(linep->line, " \t:");
  while (cp != NULL) {
	toklen = strlen(cp);
	switch (lineidx) {
		case 0:
			/* save RAID device name */
			lineidx++;
			if (toklen > 2) {
				linep->swRaidDevice = cp;
				linep->swRaidDevice_len = toklen;
			}
			break;
		case 1:
			/* check active flag (required) */
			lineidx++;
			if (!strcmp(cp, "active"))
				linep->swRaidStatus = RAIDSTATUSTC_ACTIVE;
			else if (!strcmp(cp, "inactive"))
				linep->swRaidStatus = RAIDSTATUSTC_INACTIVE;
			else
				cp = NULL;
			break;
		case 2:
			/* skip read-only flag (optional) */
			lineidx++;
			if (*cp == '(')
				break;
			/* fall through */
		case 3:
			/* check personality (optional) */
			lineidx++;
			if ((cp[0] != 's' && cp[0] != 'h') || cp[1] != 'd') {
				linep->swRaidPersonality = cp;
				linep->swRaidPersonality_len = toklen;
				break;
			}
			/* fall through */
		case 4:
			if ((cp[0] != 's' && cp[0] != 'h') || cp[1] != 'd')
				lineidx++;
			else {
				linep->swRaidUnitCount++;
				if (strstr(cp, "(F)") != NULL)
					linep->swRaidStatus = RAIDSTATUSTC_FAULTY;
				if (linep->swRaidUnits == NULL) {
					linep->swRaidUnits = cp;
					linep->swRaidUnits_len = toklen;
				} else {
					temp = &(linep->swRaidUnits[linep->swRaidUnits_len]);
					*temp++ = ' ';
					while (*cp)
						*temp++ = *cp++;
					*temp = '\0';
					linep->swRaidUnits_len += toklen + 1;
				}
			}
			break;
		default:
			cp = NULL;
			break;
	}
	if (cp != NULL)
		cp = strtok(NULL, " \t:");
  }
  return(linep->swRaidDevice_len > 0 && linep->swRaidStatus > 0);
}


/*
 * Routine to parse mdstat for errors
 */
static int ParseError(char **errmsg)
{
#define ERRMSG_STRING	"Failed RAID devices: "

  static char errbuf[MAX_LINE_LEN] = ERRMSG_STRING;
  struct input_line *curline;
  size_t errlen, mdlen;
  int errorflag = FALSE;
  char *cp;

  /*
   * Setup error message buffer
   */
  errlen = strlen(ERRMSG_STRING);
  errbuf[errlen] = '\0';

  /*
   * Parse contents of input file for error flag
   */
  curline = lines;
  while (curline != NULL) {
	mdlen = curline->swRaidDevice_len;
	if (curline->swRaidStatus == RAIDSTATUSTC_FAULTY) {
		errorflag = TRUE;
		if (errmsg != NULL && mdlen > 0 &&
		    (errlen + mdlen + 2) < sizeof(errbuf)) {
			cp = &errbuf[errlen];
			strcpy(cp, curline->swRaidDevice);
			cp = &cp[mdlen];
			*cp++ = ' ';
			*cp   = '\0';
			errlen += mdlen + 1;
		}
	}
	curline = curline->next;
  }

  /*
   * Return result
   */
  if (errmsg != NULL) {
	if (errorflag)
		*errmsg = errbuf;
	else
		*errmsg = "";
  }
  return(errorflag);
}



/*
 ****************************************************************************
 *
 * Routines to handle cached input file data
 *
 ****************************************************************************
 */

/*
 * Load input file into local cache
 */
int swRaidMIB_load(netsnmp_cache *cache, void *vmagic)
{
  FILE              *filep;
  struct input_line *curline, *lastline;
  char               buf[MAX_LINE_LEN];
  int                linecount;

  DEBUGMSGTL(("swRaidMIB", "Loading mdstat file into cache.\n"));

  /*
   * Clear old file contents
   */
  ClearFile();

  /*
   * Open our data file
   */
  if ((filep = fopen(PATH_MDSTAT, "r")) == NULL)
	return(-1);

  /*
   * Read all lines starting with "md<number>" into a linked list
   */
  lastline = NULL;
  linecount = 0;
  while (fgets(buf, sizeof(buf), filep)) {
	if (buf[0] == 'm' && buf[1] == 'd' &&
	    buf[2] >= '0' && buf[2] <= '9') {
		curline = SNMP_MALLOC_STRUCT(input_line);
		if (curline == NULL) {
			snmp_log(LOG_ERR, "Couldn't allocate memory for mdstat input line.\n");
			(void)fclose(filep);
			return(-1);
		}
		SNMP_ZERO(curline, sizeof(struct input_line));
		if (ParseLine(curline, buf)) {
			curline->swRaidIndex = ++linecount;
			curline->next = NULL;
			if (lines == NULL)
				lines = curline;
			if (lastline != NULL)
				lastline->next = curline;
			lastline = curline;
		} else {
			snmp_log(LOG_WARNING, "Error parsing mdstat input line.\n");
			free(curline);
		}
	}
  }

  /*
   * Close input file again
   */
  (void)fclose(filep);
  return(0);
}


/*
 * Free cached input file
 */
void swRaidMIB_free(netsnmp_cache *cache, void *magic)
{
  DEBUGMSGTL(("swRaidMIB", "Cleared mdstat cache.\n"));
  ClearFile();
}



/*
 ****************************************************************************
 *
 * Routines to handle row data
 *
 ****************************************************************************
 */

/*
 * Returns the first data point within the swRaidTable table data.
 *
 *  Set the my_loop_context variable to the first data point structure
 *  of your choice (from which you can find the next one).  This could
 *  be anything from the first node in a linked list, to an integer
 *  pointer containing the beginning of an array variable.
 *
 *  Set the my_data_context variable to something to be returned to
 *  you later that will provide you with the data to return in a given
 *  row.  This could be the same pointer as what my_loop_context is
 *  set to, or something different.
 *
 *  The put_index_data variable contains a list of snmp variable
 *  bindings, one for each index in your table.  Set the values of
 *  each appropriately according to the data matching the first row
 *  and return the put_index_data variable at the end of the function.
 */
netsnmp_variable_list *
swRaidTable_get_first_data_point(void **loop_context,
                                 void **data_context,
                                 netsnmp_variable_list *index,
                                 netsnmp_iterator_info *data)
{
  /*
   * Return the loop context, e.g. the first input line
   */
  *loop_context = (void *)lines;

  /*
   * Get current data context
   */
  return(swRaidTable_get_next_data_point(loop_context, data_context,
								index, data));
}


/*
 * Returns the next data point within the swRaidTable table data.
 *
 * Functionally the same as swRaidTable_get_first_data_point, but
 *  loop_context has already been set to a previous value and should
 *  be updated to the next in the list.  For example, if it was a
 *  linked list, you might want to cast it to your local data type and
 *  then return loop_context->next.  The data_context pointer
 *  should be set to something you need later and the indexes in
 *  put_index_data updated again.
 */
netsnmp_variable_list *
swRaidTable_get_next_data_point(void **loop_context,
                                void **data_context,
                                netsnmp_variable_list *index,
                                netsnmp_iterator_info *data)
{
  struct input_line *curline;

  /*
   * Return the loop context, e.g. the next input line
   */
  curline = (struct input_line *)(*loop_context);
  if (curline == NULL)
	return(NULL);
  *loop_context = (void *)(curline->next);

  /*
   * Return data context
   */
  *data_context = (void *)curline;

  /*
   * Setup index data
   */
  snmp_set_var_value(index, (u_char *)&(curline->swRaidIndex),
					sizeof(curline->swRaidIndex));
  return(index);
}



/*
 ****************************************************************************
 *
 * User-defined data access functions (per column) for table swRaidTable 
 *
 ****************************************************************************
 */

/*
 * NOTE:
 * - these get_ routines MUST return data that will not be freed (ie,
 *   use static variables or persistent data).  It will be copied, if
 *   needed, immediately after the get_ routine has been called.
 * - these SET routines must copy the incoming data and can not take
 *   ownership of the memory passed in by the val pointer.
 */

/*
 * Return a data pointer to the data for the swRaidIndex column and set
 * ret_len to its proper size in bytes.
 */
long *get_swRaidIndex(void *data_context, size_t *ret_len)
{
  struct input_line *ctx = data_context;

  if (ctx != NULL) {
	*ret_len = sizeof(ctx->swRaidIndex);
	return(&(ctx->swRaidIndex));
  }
  return(NULL);
}


/*
 * Return a data pointer to the data for the swRaidDevice column and set
 * ret_len to its proper size in bytes.
 */
char *get_swRaidDevice(void *data_context, size_t *ret_len)
{
  struct input_line *ctx = data_context;

  if (ctx != NULL) {
	*ret_len = ctx->swRaidDevice_len;
	return(ctx->swRaidDevice);
  }
  return(NULL);
}


/*
 * Return a data pointer to the data for the swRaidPersonality column and set
 * ret_len to its proper size in bytes.
 */
char *get_swRaidPersonality(void *data_context, size_t *ret_len)
{
  struct input_line *ctx = data_context;

  if (ctx != NULL) {
	*ret_len = ctx->swRaidPersonality_len;
	return(ctx->swRaidPersonality);
  }
  return(NULL);
}


/*
 * Return a data pointer to the data for the swRaidUnits column and set
 * ret_len to its proper size in bytes.
 */
char *get_swRaidUnits(void *data_context, size_t *ret_len)
{
  struct input_line *ctx = data_context;

  if (ctx != NULL) {
	*ret_len = ctx->swRaidUnits_len;
	return(ctx->swRaidUnits);
  }
  return(NULL);
}


/*
 * Return a data pointer to the data for the swRaidUnitCount column and set
 * ret_len to its proper size in bytes.
 */
long *get_swRaidUnitCount(void *data_context, size_t *ret_len)
{
  struct input_line *ctx = data_context;

  if (ctx != NULL) {
	*ret_len = sizeof(ctx->swRaidUnitCount);
	return(&(ctx->swRaidUnitCount));
  }
  return(NULL);
}


/*
 * Return a data pointer to the data for the swRaidStatus column and set
 * ret_len to its proper size in bytes.
 */
long *get_swRaidStatus(void *data_context, size_t *ret_len)
{
  struct input_line *ctx = data_context;

  if (ctx != NULL) {
	*ret_len = sizeof(ctx->swRaidStatus);
	return((long *)&(ctx->swRaidStatus));
  }
  return(NULL);
}



/*
 ****************************************************************************
 *
 * Routines to access scalar values
 *
 ****************************************************************************
 */

/*
 * Return error flag
 */
long *get_swRaidErrorFlag(size_t *ret_len)
{
  static long retval;

  DEBUGMSGTL(("swRaidMIB", "Parsing mdstat for errors.\n"));

  retval = ParseError(NULL);
  *ret_len = sizeof(retval);
  return(&retval);
}


/*
 * Return error message
 */
char *get_swRaidErrMessage(size_t *ret_len)
{
  char *retval;

  DEBUGMSGTL(("swRaidMIB", "Parsing mdstat for error devices.\n"));

  (void)ParseError(&retval);
  *ret_len = strlen(retval);
  return(retval);
}

